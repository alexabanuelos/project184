<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Texture The Tamagotchi! - Milestone Report</title>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
	<style>
		body {
			font-family: 'Inter', sans-serif;
			line-height: 1.6;
			color: #32323a;
			background-color: #ffffff;
			margin: 0;
			padding: 0;
		}

		.wrapper {
			max-width: 960px;
			margin: 0 auto;
			padding: 40px 20px;
		}

		h1, h2, h3 {
			text-align: center;
			margin-bottom: 20px;
		}

		h1 {
			font-size: 2.5em;
		}

		h2 {
			font-size: 1.5em;
			color: #666;
		}

		p {
			margin-bottom: 1.5em;
			text-align: justify;
		}

		table {
			width: 100%;
			margin: 30px 0;
			border-spacing: 20px;
		}

		td {
			text-align: center;
		}

		img {
			max-width: 100%;
			height: auto;
			border-radius: 8px;
		}

		a {
			color: #0057A8;
			text-decoration: none;
			display: block;
			text-align: center;
			margin-bottom: 1em;
		}

			a:hover {
				color: #8E018E;
				text-decoration: underline;
			}

		@media (max-width: 600px) {
			.wrapper {
				padding: 20px 10px;
			}
		}
	</style>
</head>
<body>
	<div class="wrapper">
		<h1>Project: Texture The Tamagotchi!</h1>
		<h2>Team 50: Patrick Sanchez, Karson Du, Ryssa Malibiran, Alexa Banuelos</h2>

		<main>
			<h3>Abstract</h3>
			<p>
				Texture the Tamagotchi tackles the question, "how does one apply a two-dimensional texture to a three-dimensional surface?" We used WebGL through the Three.js library to render a custom 3D model of a Tamagotchi built in Blender, an egg-shaped Japanese handheld digital pet. Our implementation features freely navigable camera controls, changeable environment backgrounds, support for custom drawn textures and images, and UV projection to spherical, cylindrical, and ellipsoidal mappings.
			</p>
			<p>
				Texture The Tamagotchi! is an interactive visualizer that allows users to upload textures for the Tamagotchi's irregular mesh surface, and compare how spherical, cylindrical, and ellipsoidal coordinate systems can be applied to approximate the UV mappings during projection. Users can inspect the surface using camera controls and compare projections against ideal primitives.
			</p>

			<h3>Technical Approach</h3>
			<p>
				Three.js is ideal for browser-based 3D rendering. We began by modeling the Tamagotchi shell in Blender and exporting it as a GLTF file. The mesh's bounding box and sphere are used to convert vertex coordinates into UV coordinates based on the selected projection mode.
			</p>
			<p>
				<strong>tamaGeoSphere:</strong> Uses spherical coordinates where theta is computed from atan2(z, x) and phi from acos(y/radius). These are normalized and used as UVs. This method exaggerates distortion near the poles.
			</p>
			<table><tr><td><img src="geosphere1.png"></td><td><img src="geosphere2.png"></td></tr></table>

			<p>
				<strong>tamaGeoEllipsoid:</strong> Uses the bounding box to normalize vertex coordinates by their respective axis radii. This maintains the shape aspect ratio and improves over the spherical method.
			</p>
			<p><img src="geoellipsoid.png"></p>

			<p>
				<strong>tamaGeoCylinder:</strong> Theta is again atan2(z, x). The Y-coordinate is normalized against the height to create the V value. Works well for vertically symmetrical shapes.
			</p>
			<p><img src="geocylinder.png"></p>

			<p>
				The tool supports user-uploaded images and a canvas-based drawing interface, applying any of these textures to the mesh in real time. Default and custom textures can be toggled with maintained state. Reference primitives are shown beside the Tamagotchi for projection comparison.
			</p>

			<h3>Challenges and Lessons</h3>
			<p>
				We encountered missing mesh faces not visible in Blenderâ€™s standard viewport. By enabling backface culling, recalculating normals resolved the issue. Understanding Three.js texture coordinate systems and mesh rotation quirks was essential. We initially explored shader-based projection but opted for direct UV mapping using mesh geometry for simplicity and control.
			</p>
			<p>
				This project required learning JavaScript, HTML, and CSS from scratch. Three.js tutorials were instrumental in setting up rendering, camera controls, and UI. Debugging was aided by visual markers and lighting experiments.
			</p>

			<h3>Results</h3>
			<table>
				<tr><td><img src="unnamed (17).png"></td><td><img src="unnamed (18).png"></td></tr>
				<tr><td><img src="unnamed (19).png"></td><td><img src="unnamed (20).png"></td><td><img src="unnamed (21).png"></td></tr>
				<tr><td><img src="static/customimage.gif"></td><td><img src="static/drawndesign.gif"></td><td><img src="static/pearto_cylinder.gif"></td></tr>
				<tr><td><img src="static/pearto_ellipse.gif (19).png"></td><td><img src="static/pearto_sphere.gif (20).png"></td></tr>
			</table>

			<h3>Milestone Video</h3>
			<a href="https://berkeley.zoom.us/rec/share/eIVuLl84i-0bYDwwxfvKSryHbGBUVzjhWDOZIfMwzfoC76wjKO7YwjS14eJr5Rjd.W4i4k6HH56xzZjm9?startTime=1746427965000">
				Link to video presentation (Passcode: cr=sNW1^)
			</a>

			<h3>Milestone Slides</h3>
			<a href="https://docs.google.com/presentation/d/1gGXqlgaeMqjzXiLi80Nmu5UzzUqG5fna9s3-FBAGtrc/edit?usp=sharing">
				Link to slide presentation
			</a>
		</main>
	</div>
</body>
</html>
